Explanation of programMy program begins by checking the amount of arguments that were passed into it. If no arguments were passed in it starts the interactive shell loop, if only one argument was passed in it reads in values from the batchfile, and anything else results in an error. The program then allocates some space for the readin buffer, the shell path, and the path list. The path list also contains by default the path “/bin”. Then if you are using the interactive loop, the shell gets the current working directory and prints it out along with the prompt “myshell>”. This does not happen in the batchfile mode. Then it reads in the user input (or reads from the batchfile in batchfile mode) and parses the input.  It takes the input string and removes any trailing or leading whitespace and then tokenizes the string based on spaces or tabs, giving us an array of strings. Then the program handles the commands. The shell will loop through the newly created array of strings and checks to see if there are any special characters (< > >> & |) or not. If there are none, it checks to see if the command is a built in command or not. If it is a builtin command, the shell will execute my own version of that command, and if not the shell will fork and make the child process do the work while the parent waits. The shell will also then look at the specified path list to see if it can find the command in of the specified paths, if it can’t it is an error if it does it executes it.  If there are special characters, the shell checks to see if they fall into one of three categories, I/O redirection only, Pipes with or without I/O redirection, and a background process. For I/O redirection only, the shell with iterate through the input and copy all the information to the left of the first I/O redirection symbol as well as check the locations of the symbols and which symbols were found. Then depending on which combination of (< > >>) was in the input, redirects the STDIN and STDOUT appropriately and uses the left buffer we created earlier to execute the command, after it restores STDIN and STDOUT back to its defaults. For piping, it starts of by creating the actual pipe and then a right and left buffer. Then it iterates through the input and copies everything to the left of the | to the left buffer and everything to the right of the | to the right buffer and it checks to see if either side had I/O redirection. Then depending on whether or not left and/or the right side had I/O redirection or not redirects STDIN and STDOUT appropriately. If I/O is found, the shell will call the function that was created in the previous paragraph and if not, it just executes the program. Then STDIN and STDOUT is restored.   The final method is for background processes. It first sets the background variable to true and iterates through the input and copies everything before the & symbol. Then it executes the command and the parent will not have to wait for the child to complete before moving on. If there are other symbols within this command the shell will handle them because the information is being sent to the initial function that was called to handle the command, so they will be dealt with. If there are multiple commands in the input (cmd1 & cmd2 & cmd3…) the shell will do the same process described above for each command. After all of this is done the shell will set the background variable back to false. The shell can be exited be entering quit or in the case of the batchfile, if it reads quit from the file or it reaches the end of the file.   Testing methodsTo test my program, I would run the shell after I finished implementing a new command. For example, when I finished implementing a new command, I would immediately run the shell to make sure that it was working properly. I also wrote two small programs that I used to help me test my shell which I have included in the submission called testfile and testfile2. I would then use these programs to test I/O redirection, to piping, and background processes. I would even use these programs to test things like path. I would try to execute these programs without putting in the proper path for them and it wouldn’t run. But after I entered the proper path it would work just fine. The following are some of the commands I used to test the shell. All of the commands would print to STDOUT or the specified output file. In = input fileOut = output file./testfile < in./testfile > out./testfile < in > out./testfile < in >> out./testfile < in | ./testfile2echo 4 | ./testfileecho 4 | ./testfile > out./testfile < in | ./testfile > outenviron > outhelp > outhelp >> out